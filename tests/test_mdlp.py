from sklearn.utils.testing import assert_array_equal
from sklearn.utils.testing import assert_equal
from sklearn.utils.testing import assert_almost_equal
from sklearn.utils.testing import assert_array_almost_equal

import sys
sys.path.insert(0, "..")

from discretization import MDLP
from _mdlp import slice_entropy
import pandas as pd
import numpy as np

def test_slice_entropy():

    y = np.array([0, 0, 0, 1, 1, 0, 1, 3, 1, 1])

    entropy1, k1 = slice_entropy(y, 0, 3)
    entropy2, k2 = slice_entropy(y, 3, 10)

    assert_equal(entropy1, 0, "Entropy was not calculated correctly.")
    assert_equal(k1, 1, "Incorrect number of classes found.")
    assert_almost_equal(entropy2, 0.796311640173813,
                        err_msg="Entropy was not calculated correctly.")
    assert_equal(k2, 3, "Incorrect number of classes found.")


def test_mdlp_iris():
    from sklearn.datasets import load_iris

    iris = load_iris()
    X = iris.data
    y = iris.target
    mdlp = MDLP(shuffle=False)
    transformed = mdlp.fit_transform(X, y)

    expected = [[ 0.,  1.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 1.,  1.,  0.,  0.],
        [ 1.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 1.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 0.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 0.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 0.,  0.,  1.,  1.],
        [ 0.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  1.,  1.,  2.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  2.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 0.,  0.,  1.,  1.],
        [ 0.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  2.,  1.],
        [ 0.,  0.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 0.,  0.,  1.,  1.],
        [ 0.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 0.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 0.,  0.,  1.,  1.],
        [ 1.,  0.,  1.,  1.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 0.,  0.,  1.,  1.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  1.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  0.,  1.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  1.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  0.,  1.,  2.],
        [ 1.,  0.,  1.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  1.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  1.],
        [ 1.,  0.,  2.,  1.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  0.,  1.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  0.,  2.,  2.],
        [ 1.,  1.,  2.,  2.],
        [ 1.,  0.,  2.,  2.]]
    assert_array_equal(transformed, expected,
                       err_msg="MDLP output is inconsistent with previous runs.")


def test_cutpoints():
    # mdlp cutpoints produced by Spark mdlp implementation by Sergio Ram√≠rez #
    feature_set = {'x1': [4.1, 19.9, 180.76, 2398.13], 'x2': [-2192.84, -549.56, 2.93, 14.25, 22.09, 336.18, 175492.79], 'x3': [508, 1205, 1681, 2938, 3196], 'x4': [1997, 4057, 7006, 11716, 19665, 1063223]}
    df = pd.read_csv("test.csv")
    for col in df.columns.values:
        # drop nan values in column #
        df_temp = df[[col, 'y']].astype(float).dropna(axis=0, how='any')
        X = df_temp.as_matrix()[:, 0:1]
        y = df_temp['y'].astype(int).as_matrix()
        mdlp = MDLP(min_depth=3)
        conv_X = mdlp.fit(X, y)
